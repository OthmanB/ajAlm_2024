import numpy as np
import os
import os.path
from  scipy.io import readsav
#from scipy import interpolate


def get_dirs_list(rootdir):
	'''
		A tiny function that scan a directory in order to find all of 
		its sub directories
	'''
	#print('os.scandir(rootdir)=', os.scandir(rootdir))
	dirs = [f.path for f in os.scandir(rootdir) if f.is_dir()]
	return dirs

def gen_data_filename(d, index, extra=None):
	'''
		Generate a string with a syntax consistent with filenames generated by the IDL PostMCMC program 
	'''
	if extra == None:
		extra=''
	err=False
	if index < 10:
		s=d+'00' + str(index) + extra + '.sav'
	if index >= 10 and index < 100:
		s=d+'0' + str(index) + extra + '.sav'
	if index >=100 and index < 1000:
		s=d + str(index) + extra + '.sav'
	if index >=1000:
		s='Cannot handle index numbers greater than 999'
		err=True
	return s, err

def read_sav(dir, ind, extra=None):
	'''
		Read an IDL sav file that is generated by the IDL PostMCMC program
	'''
	s, err=gen_data_filename(dir, ind, extra=extra)
	if err == True:
		print(s)
		exit()
	else:
		r=readsav(s)
	return r['param'], len(r['param'])

def read_parameters_length(dir, param_file):
	'''
		Read the text file that contains the parameters structure and that is generated by the IDL PostMCMC program
	'''
	plength=[]
	with open(dir + param_file, 'r') as f:
		# Skip initial comments that starts with #
		for line in f:
				plength.append(line) # Each line contains a single value

	plength=np.array(plength, dtype=int)
	return plength



def read_rot_ajAlm(d, i0_ajAlm):
	'''
		Read the rotation parameters of the MS_Global_ajAlm_Harvey_like model (available in TAMCMC version>1.80)
		The use specifies the directory of the sav files (d), the initial index at which rotation parameters are stored
		(i0_aj) and can decide to skip the reading of the parameters that handle the slope with frequency of the aj parameters
		(ignore_slope) if they wish so. Note that grid analysis of a-coefficients show that although there is a slope, this one
		does not improve the inference on the activity region if aj ~ aj_CF + aj_AR(theta, delta) (See Benomar+2022). This is why
		by default the slope is usually fixed to 0 in the TAMCMC code.
	'''
	jmax=3 # a1, a3, a5 (with a1_1, a3_1, a5_1 fixed parameters)
	Naj=2
	aj=read_rot_aj(d, i0_ajAlm, ignore_slope=True, jmax=jmax)
	# epsilon, theta, delta
	i0_Alm=i0_ajAlm + 6
	epsi, N=read_sav(d, i0_Alm) # epsi_0 (and ignore epsi_1)
	theta0, N=read_sav(d, i0_Alm+2) 
	delta, N=read_sav(d, i0_Alm+3)
	return aj, np.array(epsi,dtype=float), np.array(theta0,dtype=float), np.array(delta,dtype=float)


def read_rot_aj(d, i0_aj, ignore_slope=False, jmax=6, Naj=2):
	'''
		Read the rotation parameters of the MS_Global_aj_Harvey_like model (available in TAMCMC version>1.70)
		The use specifies the directory of the sav file (d), the initial index at which rotation parameters are stored
		(i0_aj) and can decide to skip the reading of the parameters that handle the slope with frequency of the aj parameters
		(ignore_slope) if they wish so. Note that grid analysis of a-coefficients show that although there is a slope, this one
		does not improve the inference on the activity region if aj ~ aj_CF + aj_AR(theta, delta) (See Benomar+2022). This is why
		by default the slope is usually fixed to 0 in the TAMCMC code.
	'''
	#Naj=2 # Number of paramters for each aj
	a1_param, Nsize=read_sav(d, i0_aj)
	if ignore_slope == False:
		aj_param=np.zeros((jmax, Naj, Nsize))
		cpt=i0_aj
		for j in range(0,jmax):
			for i in range(Naj):
				samples, N=read_sav(d, i0_aj+cpt)
				aj_param[j, i,:]=samples
				cpt=cpt+1
	else:
		aj_param=np.zeros((jmax, Nsize))
		for j in range(0,jmax):
				samples, N=read_sav(d, i0_aj+Naj*j)
				aj_param[j,:]=samples
	return aj_param

def read_inc(d, i0_inc):
	inc, Nsize=read_sav(d, i0_inc)
	return inc

def make_stats(samples, confidence=[2.25,16,50,84,97.75]):
	N=len(samples) 
	s=np.sort(samples)
	cdf = 100.*np.array(range(N))/float(N) # in %
	r=np.interp(confidence, cdf, s)
	return r

def make_error_from_stats(stats):
	if np.squeeze(stats).ndim > 1:
		err=np.zeros((2, len(stats[:,0]))) 
		err[0,:]=stats[:, 2] - stats[:, 1]
		err[1,:]=stats[:, 3] - stats[:, 2]
	else:
		err=np.zeros(2)
		err[0]=stats[2] - stats[1]
		err[1]=stats[3] - stats[2]
	return err

def get_freqs_median(rootdir, use_synthese=True):
	'''
		If use_synthese = True, it reads the synthese file to get the median frequencies only
		The case of use_synthese = False is not set. But the idea is to instead use an ascii output file
	'''
	if use_synthese == True:
		r=readsav(rootdir + '/synthese.sav')
		return r['stat_synthese_freq'][:,:, 3]
	else:
		print('use_synthese == False is not yet available')
		print('the program will exit now')
		exit()

def get_aj_inc_star(rootdir, confidence=[2.25,16,50,84,97.75]):
	''' 
	This program specifically analyse the results of a single star and extract information on aj coefficients
	Which are useful for a bias analysis or an ensemble analysis of aj coefficients. This means:
		- Samples of all aj-coefficients
		- Statistics at different confidence intervals (equivalent to +/- 1sigma and +/- 2 sigma)
	Note that it uses outputs generated by the IDL postMCMC program
	'''
	# Getting all of the indexes required for the process
	print("		1.  Preparing data..")
	param_file='plength.txt'
	plength=read_parameters_length(rootdir + '/Files/', param_file) # Read the parameters_length file and retrieves plength
	#Nf_el=plength[2:6] # Elements 2,3,4 and 5
	#i0_freq=sum(plength[0:2]) # Sum of elements 0 and 1 which are Nmax and lmax
	#print("plength: ", plength)
	i0_aj=sum(plength[0:6]) # First Position after Nf_el list
	i0_inc=sum(plength[0:-2]) # The last parameter is before the extra parameters that are at the end ([-1] position)
	#
	# Get the rotation parameters in form of samples
	print("		2. Gathering rotation parameters...")
	aj_samples=read_rot_aj(rootdir + '/Files/', i0_aj, ignore_slope=True) 
	jmax=len(aj_samples[:,0])
	#
	# Get the inclination in form of samples
	print("		3. Gathering inclination parameters...")
	inc_samples=read_inc(rootdir + '/Files/', i0_inc)
	#
	# Extract basic statistics from the aj samples and frequency samples
	print("		4. Get stats using the samples of all of the parameters...")
	Nconfidence=len(confidence)
	aj_stats=np.zeros((jmax, Nconfidence))
	for j in range(0, jmax):
		aj_stats[j,:]=make_stats(aj_samples[j,:], confidence=confidence)
	inc_stats=make_stats(inc_samples)
	#
	return aj_stats, inc_stats, aj_samples, inc_samples, len(aj_samples[0,:])

def get_Dnu(nu_nl0):
    x=np.linspace(0, len(nu_nl0)-1, len(nu_nl0))
    e=np.polyfit(x, nu_nl0, 1) # First order polynomial fit
    return e[0]

def reduce_samples(param, step_factor, first_sample):
    Nsamples=len(param)
    step=max([1, np.floor(step_factor)])
    Newsize=int((Nsamples -first_sample)/step_factor);
    reduced_param=np.zeros(Newsize)
    lcpt=0
    cpt=first_sample
    while lcpt<Newsize:
        reduced_param[lcpt]=param[cpt];
        cpt=cpt+step_factor;
        lcpt=lcpt+1;
    return reduced_param

def get_Dnu_samples(nu_nl0_samples):
    '''
        nu_nl0_samples: Matrix of data with all samples for all l=0 modes
    '''
    Nsamples=len(nu_nl0_samples[0,:])
    Nmodes=len(nu_nl0_samples[:,0])
    dnu_samples=np.zeros(Nsamples)
    for s in range(Nsamples):
        dnu_samples[s]=get_Dnu(nu_nl0_samples[:,s])
    return dnu_samples

def get_nu_samples(dir_sav, plength, Nsamples, verbose=False, step_factor=1, first_sample=0):
    lmax=plength[1]
    Nfl=plength[2:6]
    i0_l=[sum(plength[0:2])]
    for l in range(1,lmax+1):
        i0_l.append(sum(plength[0:2]) + sum(Nfl[0:l]))
    #
    #print('Nfl=', Nfl)
    #print('i0_l=', i0_l)
    if step_factor == 1 and first_sample == 0:
        Newsize=Nsamples
    else:
        Newsize=int((Nsamples -first_sample)/step_factor);
    nu_nl_samples=np.zeros((lmax+1, max(Nfl), Newsize))
    for l in range(lmax+1):
        for n in range(Nfl[l]):
            fnl, Nsize=read_sav(dir_sav, i0_l[l] + n)
            if Newsize == Nsamples:
                nu_nl_samples[l, n, :]=fnl
            else:
                nu_nl_samples[l,n,:]=reduce_samples(fnl, step_factor, first_sample)
            if verbose == True:
                print("    (l,n) = ({},{})  : ~ {}".format(l, n, np.median(fnl)))
    return nu_nl_samples

