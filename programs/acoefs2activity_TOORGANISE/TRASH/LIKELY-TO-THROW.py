
def get_dirs_list(rootdir):
	'''
		A tiny function that scan a directory in order to find all of 
		its sub directories
	'''
	#print('os.scandir(rootdir)=', os.scandir(rootdir))
	dirs = [f.path for f in os.scandir(rootdir) if f.is_dir()]
	return dirs

def gen_data_filename(d, index):
	'''
		Generate a string with a syntax consistent with filenames generated by the IDL PostMCMC program 
	'''
	err=False
	if index < 10:
		s=d+'00' + str(index) + '.sav'
	if index >= 10 and index < 100:
		s=d+'0' + str(index) + '.sav'
	if index >=100 and index < 1000:
		s=d + str(index) + '.sav'
	if index >=1000:
		s='Cannot handle index numbers greater than 999'
		err=True
	return s, err

def read_sav(dir, ind):
	'''
		Read an IDL sav file that is generated by the IDL PostMCMC program
	'''
	s, err=gen_data_filename(dir, ind)
	if err == True:
		print(s)
		exit()
	else:
		r=readsav(s)
	return r['param'], len(r['param'])

def read_parameters_length(dir, param_file):
	'''
		Read the text file that contains the parameters structure and that is generated by the IDL PostMCMC program
	'''
	plength=[]
	with open(dir + param_file, 'r') as f:
		# Skip initial comments that starts with #
		for line in f:
				plength.append(line) # Each line contains a single value

	plength=np.array(plength, dtype=int)
	return plength


def read_rot_aj(d, i0_aj, ignore_slope=False):
	'''
		Read the rotation parameters of the MS_Global_aj_Harvey_like model (available in TAMCMC version>1.70)
		The use specifies the directory of the sav file (d), the initial index at which rotation parameters are stored
		(i0_aj) and can decide to skip the reading of the parameters that handle the slope with frequency of the aj parameters
		(ignore_slope) if they wish so. Note that grid analysis of a-coefficients show that although there is a slope, this one
		does not improve the inference on the activity region if aj ~ aj_CF + aj_AR(theta, delta) (See Benomar+2022). This is why
		by default the slope is usually fixed to 0 in the TAMCMC code.
	'''
	jmax=6 # Maximum order for the a-coefficient
	Naj=2 # Number of paramters for each aj
	a1_param, Nsize=read_sav(d, i0_aj)
	if ignore_slope == False:
		aj_param=np.zeros((jmax, Naj, Nsize))
		cpt=i0_aj
		for j in range(0,jmax):
			for i in range(Naj):
				samples, N=read_sav(d, i0_aj+cpt)
				aj_param[j, i,:]=samples
				cpt=cpt+1
	else:
		aj_param=np.zeros((jmax, Nsize))
		for j in range(0,jmax):
				samples, N=read_sav(d, i0_aj+Naj*j)
				aj_param[j,:]=samples
	return aj_param

def read_inc(d, i0_inc):
	inc, Nsize=read_sav(d, i0_inc)
	return inc


def get_aj_inc_star(rootdir, confidence=[2.25,16,50,84,97.75]):
	''' 
	This program specifically analyse the results of a single star and extract information on aj coefficients
	Which are useful for a bias analysis or an ensemble analysis of aj coefficients. This means:
		- Samples of all aj-coefficients
		- Statistics at different confidence intervals (equivalent to +/- 1sigma and +/- 2 sigma)
	Note that it uses outputs generated by the IDL postMCMC program
	'''
	# Getting all of the indexes required for the process
	print("		1.  Preparing data..")
	param_file='plength.txt'
	plength=read_parameters_length(rootdir + '/Files/', param_file) # Read the parameters_length file and retrieves plength
	#Nf_el=plength[2:6] # Elements 2,3,4 and 5
	#i0_freq=sum(plength[0:2]) # Sum of elements 0 and 1 which are Nmax and lmax
	#print("plength: ", plength)
	i0_aj=sum(plength[0:6]) # First Position after Nf_el list
	i0_inc=sum(plength[0:-2]) # The last parameter is before the extra parameters that are at the end ([-1] position)
	#
	# Get the rotation parameters in form of samples
	print("		2. Gathering rotation parameters...")
	aj_samples=read_rot_aj(rootdir + 'Files/', i0_aj, ignore_slope=True) 
	jmax=len(aj_samples[:,0])
	#
	# Get the inclination in form of samples
	print("		3. Gathering inclination parameters...")
	inc_samples=read_inc(rootdir + 'Files/', i0_inc)
	#
	# Extract basic statistics from the aj samples and frequency samples
	print("		4. Get stats using the samples of all of the parameters...")
	Nconfidence=len(confidence)
	aj_stats=np.zeros((jmax, Nconfidence))
	for j in range(0, jmax):
		aj_stats[j,:]=make_stats(aj_samples[j,:], confidence=confidence)
	inc_stats=make_stats(inc_samples)
	#
	return aj_stats, inc_stats, aj_samples, inc_samples, len(inc_samples)



def make_stats(samples, confidence=[2.25,16,50,84,97.75]):
	N=len(samples)
	s=np.sort(samples)
	cdf = 100.*np.array(range(N))/float(N) # in %
	r=np.interp(confidence, cdf, s)
	return r

def make_error_from_stats(stats):
	err=np.zeros((2, len(stats[:,0]))) 
	err[0,:]=stats[:, 2] - stats[:, 1]
	err[1,:]=stats[:, 3] - stats[:, 2]
	return err



def get_freqs_median(rootdir, use_synthese=True):
	'''
		If use_synthese = True, it reads the synthese file to get the median frequencies only
		The case of use_synthese = False is not set. But the idea is to instead use an ascii output file
	'''
	if use_synthese == True:
		r=readsav(rootdir + '/synthese.sav')
		return r['stat_synthese_freq'][:,:, 3]
	else:
		print('use_synthese == False is not yet available')
		print('the program will exit now')
		exit()
